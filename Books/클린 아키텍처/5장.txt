좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.

그렇다면 Objected-Oriented, OO 란 대체 무엇인가? 

"데이터와 함수의 조합" 대체로 이렇게 설명하지만 만족스럽지 않다.
o.f()가 f(o)와 다르다는 의미를 내포하는데 이는 터무늬 없다.
달과 니가드가 함수 호출 스택 프레임을 힙으로 옮기고 OO를 발명한 1966 년 보다 훨씬 이전부터 프로그래머는 
데이터 구조를 함수에 전달해 왔다.

"실제 세계를 모델링하는 새로운 방법" 이라고들 답하는데 이런 정의는 너무 모호하다.

OO의 본질을 설명하기 위해 세 가지 , 캡슐화(encapsulation), 상속(inheritance)
, 다형성(polymorphism) 이 필요하다.


OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡술화하는 방법을 
OO 언어가 제공하기 때문이다. 그리고 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.

이 개념들이 실제 OO언에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.

이러한 개념이 OO에만 국한된 것은 아니다. 사실 C 언어에서도 완벽한 캡슐화가 가능하다. 아래의 간단한 C프로그램을 보자.
point.h
struct Point;
struct Point* makePoint(double x, double y)
double distance (struct Point *p1, struct Point *p2);

point.c 

#include "point.h"
#include <stdlib.h>
#include <math.h>

struct Point {
	double x,y;
};

struct Point* makepoint(double x, double y){
	struct Point* p = malloc(sizeof(struct Point));
	p -> x = x;
	p -> y = y;
	return p;
}

double distance(struct Point* p1, struct Point* p2){
	double dx = p1->x - p2->x;
	double dy = p1->y - p2->y;
	return sqrt(dx*dx+dy*dy);
}

point.h를 사용하는 측에서 struct Point의 멤버에 접근할 방법이 전혀 없다.
Point구조체의 데이터 구조와 함수가 어떻게 구현되었는지에 대해서는 조금도 알지 못한다.
이것이 바로 완벽한 캡슐화이다. 

c++ 컴파일러는 클래스의 인스턴스 크기를 알 수 있어야한다.
그래서 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언할 것을 요구했다.

point.h
class Point{
public:
	Point(double x, double y);
	double distance(const Point& p) const;

private:
	double x;
	double y;
};

이제 point.h 헤더 파일을 사용하는 측에서는 멤버 변수인 x와 y를 알게 된다.
물론 멤버 변수에 접근하는 일은 컴파일러가 막겠지만, 사용자는 멤버 변수가 존재한다는 사실 자체를 알게된다.
캡슐화가 깨진것이다.

OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을거라는 
믿음을 기반으로 한다. 하지만 OO를 제공한다고 주장한 언어들이 실제로는 C 언어에서 누렸던 완벽한 캡슐화를 약화시켜
온 것은 틀림없다.

상속? 
OO 언어가 있기 훨씬 이전에도 C프로그래머는 언어의 도움없이 순수 이러한 방식으로 구현할 수 있었다. 

namedPoint.h

struct NamedPoint;

struct NamedPoint* makedNamedPoint(double x, double y, char* name);
void setName(struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np);

namedPoint.c

#include "namedPoint.h"
#include <stdlib.h>

struct NamedPoint{
	double x,y;
	char* name;
}

struct NamedPoint* makeNamedPoint(double x, double y, char* name) {
	struct NamedPoint* p = malloc(sizeof(struct NamedPoint));
	p->x = x;
	p->y = y;
	p->name = name;
	return p;
}

void setName(strcut NamedPoint* np, char* name){
	np->name = name;
}

char* getName(struct NamedPoint* np){
	return np->name;
}

main.c

#include "point.h"
#include "namedPoint.h"
#include <stdio.h>

int main(int ac, char** av){
	struct NamedPoint* origin = makedNamedPoint(0.0, 0.0, "origin");
	struct NamedPoint* upperRight = makeNamedPoint(1.0, 1.0, "upperRight");
	printf("distance=%f\n", distance((struct Point*) origin, (struct Point*) upperRight);
}

NamedPoint가 순전히 Point를 포함하는 상위 집합으로, Point에 대응하는 멤버 변수의 순서가 그대로 유지되기 때문이다.
OO가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되었다. 
하지만 사실상 상속 만큼 편리한 방식은 절대 아니다. 
또한 NamedPoint 인자를 Point로 타입을 강제로 변환한 점도 확인할 수 있다. 
진짜 OO언어에서는 이러한 업스캐팅이 암묵적으로 이뤄진다. 


다형성? 

OO 언어가 있기 이전에 다형성을 표기할 수 있는 언어가 있었던가? 당연히 있었다.

#include <stdio.h>
void copy() {
	int c;
	while( (c=getchar()) != EOF )
		putchar(c);
}

getchar() 함수는 STDIN에서 문자를 읽는다.
그러면 STDIN은 어떤 장치인가? putchar() 함수는 STDOUT으로 문자를 쓴다. 
그런데 STDOUT은 또 어떤 장치인가? 이러한 함수는 다형적(polymorphic)이다.
즉, 행위가 STDIN과 STDOUT의 타입에 의존하다.

모든 입출력 장치 드라이버가 다섯 가지 표준 함수를 제공할 것을 요구한다.
열기(open), 닫기(close), 읽기(read), 쓰기(write), 탐색(seek)이 표준 함수들이다. 

FILE데이터 구조는 이들 다섯 함수를 가리키는 포인터들을 포함한다. 이 예제의 경우라면 다음과 같을 것이다.

Struct FILE {
	void (*open) (char* name, int mode);
	void (*close) ();
	int (*read) ();
	void (*write) (char);
	void (*seek) (long index, int mode);
};

콘솔용 입출력 드라이버에서는 이들 함수를 아래와 같이 정의하며, FILE 데이터 구조를 함수에 대한
주소와 함께 로드할 것이다.

#include "file.h"

void open(char* name, int mode) {~~}
void close() {~~
int read() {~~}
void write(char c){~}
void seek(long index, int mode) {~}

struct FILE console = {open, close, read, write, seek};

이제 STDIN을 FILE*로 선언하면, STDIN은 콘솔 데이터 구조를 가리키므로, getchar()는 아래와 같은 방식으로 구현할 수 있다.

extern struct FILE* STDIN;

int getchar() {
	return STDIN -> read();
}

다시 말해 getchar()는 STDIN으로 참조되는 FILE 데이터 구조의 read포인터가 가리키는 함수를 단순히 호출할 뿐이다.
이처럼 단순한 기법이 모든  OO가 지닌 다형성의 근간이 된다. 

함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데, 함수 포인터는 위험하다는 사실이다.
이러한 기법은 프로그래머가 특정 관례를 수동으로 따르는 방식이다.
즉 포인터를 초기화하는 관례를 준수해야 한다는 사실을 기억해야한다. 그리고 이들 포인터를 통해 모든 함수를 호출하는 
관례를 지켜야 한다는 사실을 망각하게 되면 버그가 발생하고, 이러한 버그는 찾아내고 없애기가 지독히도 힘들다.

이러한 이유로 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수있다.


플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어 졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.
그럼에도 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 가리키는
포인터를 사용하면 위험을 수반하기 떄문이다.
OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적요할 수 있게 되었다. 

전형적인 호출 트리의 경우 main 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며, 중간수준
함수는 다시 저수준 함수를 호출한다. 이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.

main함수가 고수준 함수를 호출하려면 고수준 함수가 포함된 모듈의 이름을 지정해야만 한다.
c의 경우 이러한 지정자는 #include다. 이러한 제약 조건으로 인해 소프트웨어 아키텍트에게 남은 선택지가 없다.
즉 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.

그림 5.2 참고(49p)
HL1 모듈은 ML1 모듈의 F() 함수를 호출한다. 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다.
이 인터페이스는 런타임에는 존재하지 않는다. HL1 모듈의 함수 F()를 호출할 뿐이다.
하지만 ML1과 I인터페이스 사이의 소스코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자.
이는 의존성 역전(dependency inversion)이라고 부른다.

OO언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는
절대적인 권한을 갖는다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.
호출하는 모듈이든 아니면 호출받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정 할 수 있다.
이것이 OO의 힘이다. 
 
결론 
OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
OO를 사용하면 아키텍트는 프러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의
세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고,
고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수  있다. 



